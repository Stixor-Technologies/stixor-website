/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useEffect, useRef, useState } from "react";
import styles from "./services.module.css";
import {
  useGLTF,
  useAnimations,
  useHelper,
  useCamera,
  Bounds,
  useBounds,
  OrbitControls,
  ContactShadows,
  useTexture,
} from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { useFrame, useThree } from "@react-three/fiber";
import {
  Camera,
  CameraHelper,
  MathUtils,
  PerspectiveCamera,
  PointLight,
  PointLightHelper,
} from "three";
type GLTFResult = GLTF & {
  nodes: {
    Cube011: THREE.Mesh;
  };
  materials: {};
};

export function ServicesNew(props: JSX.IntrinsicElements["group"]) {
  const { nodes, materials } = useGLTF(
    "/assets/models/Services_without_texture.glb"
  ) as unknown as GLTFResult;

  const texture = useTexture("/images/textures/Services_Textures.jpg");
  texture.flipY = false;
  texture.magFilter = THREE.NearestFilter;

  const Camera = () => {
    const [width, setWidth] = useState<any>();

    useEffect(() => {
      if (window !== undefined) {
        setWidth(window.innerWidth);
      }
    }, [width]);

    useThree(({ camera }) => {
      // camera.position.set(5.99, 1.21, -0.008);

      camera?.position.lerp(vec.set(5.99, 1.21, -0.008), 0.5);
      camera.lookAt(3, 1, 0);
    });
    useFrame(({ camera }) => {
      // console.log("camera", camera.position);
      // console.log("rot", camera.rotation);
    });
    return null;
  };

  const Lights = () => {
    const light = useRef(null);
    useHelper(light, PointLightHelper, 1, "red");

    return (
      <>
        <ambientLight intensity={10} color={0x404040} />
        <pointLight ref={light} position={[12.5, 5, 8.7]} />
      </>
    );
  };
  const vec = new THREE.Vector3();
  // useFrame((state) => {
  //   const step = 0.05;

  //   state.camera?.position.lerp(vec.set(5.99, 1.21, -0.008), 0.5);
  //   state.camera.lookAt(3, 1, 0);

  //   state.camera.updateProjectionMatrix();
  // });

  return (
    <group dispose={null}>
      <Camera />
      <Lights />
      <mesh
        geometry={nodes.Cube011.geometry}
        material={nodes.Cube011.material}
        position={[-0.21, 0, 0.07]}
        rotation={[Math.PI, -0.29, Math.PI]}
        scale={0.48}
      >
        <meshBasicMaterial map={texture} />
      </mesh>
    </group>
  );
}

useGLTF.preload("/Services_without_texture.glb");
